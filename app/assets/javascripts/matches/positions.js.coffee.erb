# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://coffeescript.org/

# TODO: DRY UP ANALYSIS JAVASCRIPT FILES (PULL OUT HELPER/UTILITY STUFF)
window.DOTA2RAILS.matches.components.map = (() ->
  mapfile = "<%= asset_path 'dota_gray_blur_600x580.jpg' %>"
  world_to_img = (x,y) ->
    x: (8576.0 + x) * 0.0366 + -12.4219,
    y: (8192.0 - y) * 0.0367 + -1.2082
  mapw = 600
  maph = 580

  # we want these variables to persist between init and update funcs
  positions = heroes = svg = icon_container = null

  init = ->
    positions = gon.match.positions
    heroes = (name for name of positions when name isnt 'time')

    svg = d3.select("#map").append("svg")
        .attr("width", mapw)
        .attr("height", maph)
    imgs = svg.selectAll("image").data([mapfile])
    imgs.enter().append("svg:image")
      .attr("xlink:href", (d) -> d)
      .attr("width", mapw)
      .attr("height", maph)
    icon_container = svg.append("g")

  # positions map
  update = (time, time_interval) ->
    for pos,idx in positions['time']
      break if pos > time
    data = []
    for h,i in heroes
      continue if idx > positions[h].length - 1
      data.push {}
      pos = world_to_img positions[h][idx][0], positions[h][idx][1]
      team = if h in gon.match.player_teams['radiant'] then 'radiant' else 'dire'
      $.extend(data[i], {name: h, team: team, hp: positions[h][idx][2]}, pos)
    #console.log time

    # DATA JOIN
    # TODO: group icons and hp_bars under parent element (g)
    #       and apply update movements to that single element
    #hero_icons = svg.selectAll("rect")
    #  .data(data, (d) -> d.name)
    hero_icons = icon_container.selectAll("image")
      .data(data, (d) -> d.name)
    hp_bars = icon_container.selectAll("rect")
      .data(data, (d) -> d.name)

    # UPDATE
    hero_icons.transition().duration(time_interval).ease(d3.ease('linear'))
        .attr("x", (d) -> d['x'] - 16) # subtract half of sprite width
        .attr("y", (d) -> d['y'] - 16) # subtract half of sprite height
    hero_icons.classed('desaturate', (d) -> d['hp'] <= 0)
    hp_bars.transition().duration(time_interval).ease(d3.ease('linear'))
        .attr("width", (d) -> d['hp'] / 100 * 32)
        .attr("x", (d) -> d['x'] - 16) # subtract half of sprite width
        .attr("y", (d) -> d['y'] + 18) # subtract half of sprite height

    # ENTER
    #hero_icons.enter().append("rect")
    hero_icons.enter().append("svg:image")
        .attr("x", (d) -> d['x'] - 16) # subtract half of sprite width
        .attr("y", (d) -> d['y'] - 16) # subtract half of sprite height
        #.attr("width", 5)
        #.attr("height", 5)
        .attr("width", 32)
        .attr("height", 32)
        # changed this because asset path fingerprinting means I don't know
        # what the image file's name is in production
        # so, the image paths are written into the bottom of the html page
        #.attr("xlink:href", (d) -> "/assets/miniheroes/#{d['name'].substring(14)}.png")
        .attr("xlink:href", (d) -> window.DOTA2RAILS.matches.heroiconpaths[d.name])
        #.attr("viewBox", "0 0 32 32")
        #.style("fill", (d, i) -> colors[i])
    hp_bars.enter().append("rect")
        .attr("fill", (d) -> if d['team'] is "radiant" then "rgba(0,255,0,0.5)" else "rgba(255,0,0,0.5)")
        .attr("height", 2)
        .attr("width", (d) -> d['hp'] / 100 * 32)
        .attr("x", (d) -> d['x'] - 16) # subtract half of sprite width
        .attr("y", (d) -> d['y'] + 18) # subtract half of sprite height

    # ENTER + UPDATE

    # EXIT
    hero_icons.exit().remove()
    #hp_bars.exit().remove()

  #timer_tick = positions['tick'][0]
  #update_wrapper = ->
    #timer_tick += 150
    #clearInterval(timer) if data.length is 0
    #update timer_tick, data
  #timer = setInterval update_wrapper, 100
  {init: init, update: update}
)()
